/* 黑暗的字符串
   一个只包含'A',"B",'C'的字符串，如果存在某段长度为3的连续子串中恰好'A','B','C'各一个，那麽这段字符串就是纯净的，否则这段字符串是黑暗的。如：BAACAACCBAAA连续子串中包含了'A','B','C'各一个，所以是纯净的字符串
   AABBCCAABB不存在一个长度为3的连续子符串包含'A','B','C',所以是暗黑字符串。
   你的任务就是计算出长度为n的字符串(只包含'A','B','C'),有多少个暗黑的字符串。
   输入描述：
   输入一个整数n，表示字符串长度
   输出描述：
   输出一个整数表示有多少个暗黑字符串
*/
import java.util.Scanner;
public class DarkString{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        while(in.hasNext()){
            int n = in.nextInt();
            System.out.println(dp(n));
        }
    }
    public static long dp(int n ){
        long[] dp = new long[n+1];
        dp[0] = 0;
        dp[1] = 3;
        dp[2] = 9;
        for(int i = 3; i <= n; i++ ){
            dp[i] = 2 * dp[i-1] + dp[i - 2];
        }
        return dp[n];
    }
}
/* 动态规划的解题思路
   在本题中，如果要求长度为n的暗黑字符串，先假设和前一个n-1的暗黑字符串相关，那麽从前一个往后扩展一位，就需要加ABC其中一个字母，此时要保证还是暗黑串，就需要考察n-1状态时末尾两个字母的状态，末尾两个字母的状态只有相同和不同两种。
   1.如果相同(假设有S(n-1)个)，那麽新增的字母ABC都可以，有3*S(n-1)
   2.如果不相同(假设有D(n-1)个)，那麽新曾的字母只能是那两个字母中的一个，由2*D(n-1)
   由此可以得到f(n)=3*S(n-1)+2*D(n-1)=3*S(n-1)+2*f(n-1)
   这里发现多了一个S(n-1)项无法消除，因为S(n-1)是f(n-1)的一个子集，我们需要更前面的状态，比如f(n-2)中区寻找S(n-1)和f(n-2)的关系。
   此时在观察上文的两个情况分析：
   1.如果相同(假设有D(n-1)个)，那麽新增的字母abc都可以，有3*S(n-1)种。
   这其中有1/3结果是相同的，个数是S(n-1)，而不同的有2*S(n-1).如AA分别变为AAA，AAB，AAC
   2. 如果不同(假设有D(n-1)个)，那麽新增的的字母只能是两个字母中的一个，有2*D(n-1)中。如AB变成ABA，ABB
   所以f(n-1) = S(n-1)+D(n-1)
   有以上分析得到：
   S(n) = S(n-1)+D(n-1)
   D(n) = 2*S(n-1)+D(n-1)
   所以S(n) = f(n-1);
   带入f(n) = 3*S(n-1)+2*D(n-1) = 2f(n-1)+S(n-1)
   得到
   f(n) = 2*f(n-1)+f(n-2)
*/
