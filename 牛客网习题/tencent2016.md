# 腾讯2016研发工程师

 1.什么是内存对齐

假设我们同时声明两个变量：

char a;

short b;

用&（取地址符号）观察变量a，

b的地址的话，我们会发现（以16位CPU为例）：

如果a的地址是0x0000，那么b的地址将会是0x0002或者是0x0004。

那么就出现这样一个问题：0x0001这个地址没有被使用，那它干什么去了？ 答案就是它确实没被使用。 因为CPU每次都是从以2字节（16位CPU）或是4字节（32位CPU）的整数倍的内存地址中读进数据的。如果变量b的地址是0x0001的话，那么CPU就需要先从0x0000中读取一个short，取它的高8位放入b的低8位，然后再从0x0002中读取下一个short，取它的低8位放入b的高8位中，这样的话，为了获得b的值，CPU需要进行了两次读操作。 

但是如果b的地址为0x0002，

那么CPU只需一次读操作就可以获得b的值了。所以编译器为了优化代码，往往会根据变量的大小，将其指定到合适的位置，即称为内存对齐（对变量b做内存对齐，a、b之间的内存被浪费，a并未多占内存）。

2.结构体内存对齐规则（请记住三条内存规则(在没有#pragam pack宏的情况下）

结构体所占用的内存与其成员在结构体中的声明顺序有关，其成员的内存对齐规则如下：

（1）每个成员分别按自己的对齐字节数和PPB（指定的对齐字节数，32位机默认为4）两个字节数最小的那个对齐，这样可以最小化长度。如在32bit的机器上，int的大小为4，因此int存储的位置都是4的整数倍的位置开始存储。

（2）复杂类型(如结构)的默认对齐方式是它最长的成员的对齐方式，这样在成员是复杂类型时，结构体数组的时候，可以最小化长度。

（3）结构体对齐后的长度必须是成员中最大的对齐参数（PPB）的整数倍，这样在处理数组时可以保证每一项都边界对齐。
 （4）结构体作为数据成员的对齐规则：在一个struct中包含另一个struct，内部struct应该以它的最大数据成员大小的整数倍开始存储。如 struct A 中包含 struct B, struct B 中包含数据成员 char, int, double，则 struct B 应该以sizeof(double)=8的整数倍为起始地址。 

`32位编译器：32位系统下指针占用4字节`

char` `：1个字节`

char *（即指针变量）: 4个字节（32位的寻址空间是2^32, 即32个bit，也就是4个字节。同理64位编译器）`

  short` `int` `: 2个字节`

    int  ：  4个字节`

`      ``unsigned ``int` `: 4个字节`

`      ``float``:  4个字节`

`      ``double``:   8个字节`

`      ``long``:   4个字节`

`      ``long` `long``:  8个字节`

`      ``unsigned ``long``:  4个字节`

`64位编译器：64位系统下指针占用8字节`

`      ``char` `：1个字节`

`      ``char``*(即指针变量): 8个字节`

`      ``short` `int` `: 2个字节`

`      ``int``：  4个字节`

`      ``unsigned ``int` `: 4个字节`

`      ``float``:  4个字节`

`      ``double``:   8个字节`

`      ``long``:   8个字节`

`      ``long` `long``:  8个字节`

`      ``unsigned ``long``:  8个字节`

```c++
struct A{
 long a1;
 short a2;
 int a3;
 int *a4;
};
```

请问在64位编译器下用sizeof(struct A)计算出的大小是：

`第一个，8字节`

`第二个，2字节，加起来是10，对齐到12`

`第三个，4字节，加起来是16`

`第四个，8字节，加起来是24`

所以一共是24字节

## 运输层

网络层是为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。根据应用程序的不同需求，运输层需要两种不同的运输协议，即面向连接的TCP和无连接的UDP。

UDP的主要特点：

1. UDP是无连连接的，即发送数据前不需要建立连接
2. UDP使用尽最大努力交付
3. UDP是面向报文的
4. UDP没有拥塞控制
5. UDP支持一对一、一对多和多对多的交互通信
6. UDP的首部开销小，只有8字节，比TCP的20个字节的首部要短。

UDP的首部8个字节，由四个字段组成，分别是源端口、目的端口、长度和检验和

TCP主要特点：

1. TCP是面向连接的运输层协议，也就是说，应用程序在使用TCP协议之前，必须建立TCP连接。
2. 每条TCP连接只能有两个端点，每一条TCP连接只能点对点
3. TCP提供可靠交付的服务，通过TCP连接传送的数据，无差错、不丢失、不重复并且按序到达
4. TCP提供全双工通信。TCP允许通信双方的应用程序在任何时候到都能发送数据。TCP连接的两端都设有缓存和接受缓存。
5. 面向字节流

每条TCP连接唯一的被通信两端的两个端点(即两个套接字)所确定。套接字 =( IP地址：端口号)

停止等待协议：

停止等待就是每发送完一个分组就停止发送，等待对方确认。在收到确认后再发送下一个分组。

发送方只要超过一段时间仍没收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组，这就叫超时重传。

这里要注意一下三点：

第一、发送方发送一个分组后，必须暂时保留已发送的分组副本

第二、分组和确认分组都必须进行编号

第三、超时器设计重传时间要比数据在分组传输的平均往返时间更长点

信道利用率

假定A发送分组需要的时间是$$ T_{d} $$ .显然$$ T_{d} $$ 等于分组长度除以数据率。在假定分组正确到达B后，B处理分组的时间可以乎略不计。同时B发送确认。假定B发送确认分组的时间$$ T_{A} $$ .如果A处理确认分组的时间也乎略不计，那麽A在经过时间$$ (T_{D} + RTT + T_{A}) $$ 后就可以发送下一个分组。这里RTT是往返时间。信道利用率可用下式计算：

$ U = \frac{T_{D}}{T_{D} + RTT + T_{A}} $ 

[![img](http://uploadfiles.nowcoder.com/images/20160328/708096_1459154705476_906EC15DE765CD30F629C27EDB1A8711)

CP连接断开的状态包括：FIN-WAIT-1、CLOSE-WAIT、FIN-WAIT-2、LASR-ACK、TIME-WAIT、CLOSE

**当某个连接的一端处于TIME_WAIT状态时，该连接将不能再被使用。fin_wait1状态是在server端主动要求关闭tcp连接，并且主动发送fin以后，等待client端回复ack时候的状态。Server端强制断开Socket时向客户端发送了FIN请求，客户端已经没有能力继续回复ACK，造成了服务器端大量的端口处在FIN_WAIT_2状态**

C语言中，|是按位或 i=5,j=7 i |j = 7; || 逻辑或 i ||  j = 1.

```c++
int a = 10;
int b = 4;
int c = a / b; // c = 2
int d = c * a * b++; // d = 2 * 10 * 4++，b在运算之后自增为b = 5
printf("%d\n", d); // 80
// 若写成 d=c*a*++b;  是先去做 b=b+1，然后再把b作为表达式的结果  则为100 
```

```c++
#include<stdint.h>
#include<stdio.h>
union X
{
    int32_t a;
    struct 
    {
        int16_t b;
        int16_t c;
    };
};
int main(){
    X x;
    x.a=0x20150810;
    printf("%x,%x\n",x.b,x.c);
    return 0;
}
```

>   0x20150810
>
>   如果按照大端模式存储：从低地址到高地址：20 15 08 10
>
>                                     输出从低地址到高地址：20 15 08 10
>
>   如果按照小端模式存储：从低地址到高地址：10 08 15 20 
>
>                                     输出从高地址到低地址：08 10 20 15

```c++
#include<iostream>
using namespace std;
int i=1;
class MyCls{
public:
    MyCls():m_nFor(m_nThd),m_nSec(i++),m_nFir(i++),m_nThd(i++){
        m_nThd=i;
    }
    void echo(){
        cout<<"result:"<<m_nFir+m_nSec+m_nThd+m_nFor<<endl;
    }
private:
    int m_nFir;
    int m_nSec;
    int m_nThd;
    int &m_nFor;
};
int main()
{
    MyCls oCls;
    oCls.echo();
    return 0;
}
```

> 首先要明白变量初始化的顺序是其声明的顺序,跟初始化列表中的顺序无关。所以变量的初始化顺序为m_nFir(i++)，m_nSec(i++)，m_nThd(i++)，&m_nFor(m_nThd);
>
> ​        i初始值为1，所以经过初始化列表初始化以后m_nFir=1，m_nSec=2，m_nThd=3，m_nFor为m_nThd的一个引用。
> ​      
> ​        并且此时i的值为4，构造函数中执行语句m_nThd=i后，m_nThd=4,m_nFor是它的一个引用，自然值也为4。
>
> ​        输出结果m_nFir+m_nSec+m_nThd+m_nFor=1+2+4+4=11    
> ​    

  作业归还分区，要调整空闲区表，把空闲区表调整成空闲区长度递减的次序排列登记。可变分区分配方式下，当收回主存时，应检查是否有与归还区相邻的空闲区，若有，则应合并成一个空闲区。 

  相邻可能有上邻空闲区、下邻空闲区、既上邻又下邻空闲区、既无上邻又无下邻空闲区四种情况。 

1. ​     有上邻空闲区，但无下邻空闲区.只修改上邻空闲区长度（为收回的空闲区长度与原上邻区长度之和），空闲区数不变      
2. ​        无下邻空闲区，但有下邻空闲区.改记录这个下邻空闲区记录的地址为收回空闲区的地址，长度为下邻空闲区的长度和收回空闲区的长度，空闲区数不变      
3. ​        有上邻空闲区，也有下邻空闲区.改记录上邻区记录的长度（为上邻区长度、下邻区长度和收回区长度之和），再把下邻区记录的标志位改为空，即空闲区数-1      
4. ​        无上邻空闲区，也无下邻空闲区.那么找一个标志位为空的记录，记下该回收区的起始地址和长度，且改写相应的标志位为未分配，表明该登记栏中指示了一个空闲区。        空闲区数+1    