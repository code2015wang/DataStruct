# 实战java虚拟机 ---jvm故障诊断与性能优化

## 初探java虚拟机

​     所谓虚拟机，就是一台虚拟的计算机。它是一款软件，用来执行虚拟计算机指令。大体上虚拟机可以分为系统虚拟机和程序虚拟机。程序虚拟机的典型代表是java虚拟机，它专门用来执行单个计算机程序而设计，在java中执行的指令我们称为java字节码指令。hotspot虚拟机

java虚拟机规范的主要内容大概有以下几个部分：

1. 定义虚拟机的内部结构
2. 定义虚拟机执行的字节码类型和功能
3. 定义了class文件的结构
4. 定义了类的加载、连接和初始化

所谓原码就是符号位加上数字的二进制表示;反码就是在原码的基础上，符号位不变，其余位取反;补码：正数的补码是原码，负数的补码是反码加1.

## 认识java虚拟机的基本结构

![1482221955283191](/down/DataStruct/1482221955283191.png)

类加载子系统负责从文件系统或者网络中加载class信息，加载的类信息存放在一块称为方法区的内存空间。除了类的信息外，方法区可能还会存放运行时常量池的信息，包括字符串字面量和数字常量。

java堆在虚拟机启动的时候建立，它是java程序最主要的内存工作区域。几乎所有java对象的实例都放在java堆里。堆空间是所有线程共享。

java的NIO库允许java程序程序使用直接内存。直接内存是在java堆外、直接向系统申请的内存空间。通常，访问直接内存的速度会优于java堆。因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。

垃圾回收机制是java虚拟机的重要组成部分，垃圾回收器可以对方法区、java堆和直接内存进行回收。其中java堆是垃圾回收器的工作重点。垃圾回收系统会在后台默默工作，默默查找、标识并释放垃圾对象，完成包括java堆、方法区和直接内存中的全自动化管理。

每一个java虚拟机线程都有一个私有的java栈，一个线程的java栈在线程创建的时候被创建。java栈中保存局部变量、方法参数，同时和java方法的调用、返回密切相关。

本地方法栈和java栈类似，但java栈用于java方法，而本地栈用于本地方法调用。作为对java虚拟机的重要扩展，java虚拟机允许java直接调用本地方法。

PC寄存器也是每一个线程的私有空间，java虚拟机会为每个java线程创建PC寄存器。

执行引擎是java虚拟机的最核心组件之一，它负责执行虚拟机的字节码

###  设置java虚拟机参数

java虚拟机可以使用java来启动，java的命令行使用方法如下：

java [-option] calss [args....]

其中 ，-option 表示java虚拟机启动的参数，class为带有main（）函数的java类 ，args表示传递给主函数main（）的参数。

-Xmx 32m 指定系统最大可用堆空间为32MB

-Xss 来指定线程最大栈空间

程序如何调用：出入java栈。java栈是一块线程私有的内存空间。线程的基本行为是函数调用，每次函数调用都是通过java栈传递的。在java栈中包存的主要内容是栈帧。栈帧主要由局部变量表、操作数栈和帧数据区。局部变量是栈帧的主要组成部分之一，它用于保存函数的参数以及局部变量。局部变量表中变量只对当前函数有效，当函数数调用结束后，随着函数的栈帧销毁，局部变量表随之销毁。操作数栈，主要用于保存计算过程中的中间结果，同时作为计算过程中变量临时存储空间。帧数据区中保存着访问常量池的指针，方便程序访问常量池。

方法区用于保存系统的类信息，比如类的字段、方法、常量池等。方法区的大小决定了系统可以保存多少个类。如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误。

## 常用java虚拟机参数

### 掌握跟踪调试参数

1. 跟踪垃圾回收-----读懂虚拟机日志

最简单的一个GC参数是 -XX：+PrintGC，使用这个参数后启动java虚拟机后，只要遇到GC就会打印日志。

如果需要更加详细的信息，则可以使用-XX：+PrintGCDetails参数

如果需要更全面的信息，我们可以使用 -XX：+PrintHeapAtGC。它会在每次GC前后分别每次打印堆信息。

如果分析GC发生的时间，还可以使用-XX:+PrintGCTimeStamp，该参数会在GC时，额外输出GC发生的时间，该输出时间为虚拟机启动后的时间偏移量。

2. 类加载/卸载的跟踪

java程序的运行离不开类，为了更好的理解程序，有时候需要知道程序加载了那些类。随着动态代理、AOP技术的普遍使用，系统由可能也极有可能在运行时动态生成某些类，这些类比较隐蔽，无法通过文件系统找到，为此虚拟机提供了类加载/卸载跟踪参数就显得格外有意义。

可以使用参数-verbose:class 跟踪类的加载/卸载。也可以单独使用参数 -XX:+TraceClassLoading跟踪类的加载，使用参数-XX:+TraceClassUnloading跟踪类的卸载。

3. 系统参数查看

参数-XX:PrintVMOptions可以在程序运行时，打印虚拟机接受的命令行显式参数

### 让性能飞起来：学习堆的配置参数

1. 最大堆和初始堆的设置

当java进程启动时，虚拟机就会分配一块初始堆空间，可以使用参数 -Xms 指定这块堆空间的大小，最大堆空间可以使用-Xmx指定。

### client和server二选一：虚拟机的工作模式

目前虚拟机支持Client和Server两种运行模式。使用参数-client可以指定使用Client模式。使用参数-seerver可以指定使用Server模式。与client模式相比，server模式启动比较慢，但系统完全启动并进入稳定1期server模式的执行速度远远快于client模式。因此，对于后台运行时间长的应用，使用server模式更合适。

### JDK性能监控工具

1. 查看java进程----jps命令

命令jps用于列出java进程。直接运行jps命令不加任何参数，可以列出java进程ID以及main函数的短名称。

-p 只输出进程id，而不输出类的短名称

-m 可以输出传递给java进程（主函数）的参数

-l  可以列出主函数的完整路径

-v 显示传递给java虚拟机的参数

2. 查看虚拟机运行时的信息--jstat命令

jsata是一个可以查看java程序运行时相关信息的工具，它功能非常强大，可以通过它查看堆的信息的详细情况。它的基本语法如下：

```
jstat -<option> [-t] [-h ] <vmid> [< interval > [<count >]]
```



+ option可以由以下值构成：

  -class  显式classLoader的相关信息

  -complier   显式JIT编译相关信息

  -gc  显式GC相关信息

  -gcccapacity 显示各个代的容量以及使用情况

  -gcccause 显式垃圾收集相关信息

  -gcnew  显示新生代信息

  -gcnewcapacity  显示新生代大小与使用情况

  -gcold  显示老年代和永久代的信息

  -gcoldcapacity  显示老年代的大小

  -gcpermcapacity  显示永久代的大小

  -gcutil  显示垃圾收集信息

  -printcompilation  输出JIT编译的方法信息

  -t 显示程序的运行时间

3. 查看虚拟机参数 ---- jinfo命令

jinfo可以用来查看正在运行的java应用程序的扩展参数，甚至支持在运行时，修改部分参数。它的基本语法为：

```
jinfo  <option>  <pif>
```

其中option可以为以下信息：

-flag <name>  ：打印指定java虚拟机的参数值

-flag  [+|-] <name>:  设置指定java虚拟机参数的布尔值

-flag <name>=<value>   设定指定java虚拟机参数的值

在很多情况下，java程序不会指定所有的java虚拟机参数 。而此时，开发人员可能不知道某一个具体的java参数的默认值。通过jinfo工具，开发人员可以很方便的找到java虚拟机参数的当前值。

4. 导出堆到文件---jmap命令

命令jmap是一个多功能命令。它可以生成java程序的堆Dump文件，也可以查看堆内对象实例的统计信息、查看ClassLoader的信息以及finalizer队列。最重要的功能是得到java程序的当前堆快照。

5. jdk自带的堆分析工具-----jhat命令

使用jhat工具可以用于分析java应用程序的堆快照内容。

6. 查看线程堆栈----jstack命令

jstack可用于导出java应用程序的线程堆栈，语法为：

```
jsatck  [-l]  <pid>
```

jstack 工具会在控制台输出程序中所有的锁信息，可以重定向将输出保存到文件。通过jstack工具不仅可以得到线程堆栈，它还能自动进行死锁检查，输出找到的死锁信息。

7. 远程主机信息收集-----jstatd

命令jstatd是一个RMI服务端程序，它的作用相当于代理服务器，建立本地计算机与远程监控工具的通信。jstatd服务器将本地的java应用程序信息传递到远程计算机。直接打开jstatd服务器可能会抛出异常。这是由于程序没有足够大的权限所致。可以使用java的安全策略，为其分配相应的权限。

8. 多功能命令行---jcmd

命令jcmd可以用它来导出堆、栈、查看java进程、导出进程消息、执行GC。

参数 -l  表示列出所有的java虚拟机，针对每一个虚拟机，jcmd可以使用help命令列出他们所支持的命令

9. 性能统计工具---hprof

hprof不是独立的监控工具，它只是一个java agent 工具。它可以用于监控java应用程序在运行时的CPU信息和堆信息。使用java -agentlib：hprof=help 命令可以查看hprof的帮助文档。

10. 图形化虚拟机监控工具jconsole

jConsole 工具是JDK自带的图形化性能监控工具。通过jConsole工具，可以查看java应用程序的运行情况，可以监控堆信息、永久区使用情况、类加载情况等。

# 分析java堆

内存一直是应用系统中最为重要的组成部分，在java应用中，系统内存通常会被分为几块不同的空间，了解这些不同内存区域的作用有助于更好编写java应用，构建更加稳定的系统。而堆空间更是java内存中最为重要的区域，几乎所有的应用程序对象都在堆中分配，当系统出现故障时，具备java堆的分析能力，也可以方便的诊断系统的故障。

1. 找出内存溢出的原因

内存溢出（OOM）是一个令人头疼的问题，它通常出现在某一块内存空间耗尽的时候。在java程序中，导致内存溢出的原因很多，需要具体分析。

+ 堆溢出

堆是java程序中最为重要的内存空间，由于大量的对象都直接分配在堆上，因此它也成为最有可能发生溢出的区间。一般来说，绝大多数java的内存溢出都属于这种情况。其原因是因为大量对象占据了堆空间，而这些对象都持有强引用，导致无法回收，当对象大小之和大于由XmX参数指定的堆空间大小时，溢出错误就自然而然的发生了。

为了缓解堆溢出错误，一方面可以使用-Xmx参数指定一个更大的空间，另一方面，由于堆空间不能无限增大，通过工具分析找到大量占用堆空间的对象，并在应用程序上做出合理的优化也是十分有必要的。

+ 直接内存溢出

在java得NIO（new IO）中，支持直接内存的使用，也就是通过java代码，获得一块堆外存空间，这块空间是直接向操作系统申请的。直接内存的申请速度一般比堆内存慢。但其访问速度要快。因此，那些可复用的，并且会被经常访问的空间，使用直接内存是可以提高系统性能。但由于直接内存没有被java虚拟机托管，若使用不当，也容易触发直接内存溢出，导致宕机。

+ 过多线程导致OOM

由于每一个线程的开启都要占用系统内存，因此当线程数量太多时，也有可能导致OOM。由于线程空间也是在堆外分配的，因此和直接内存非常相似，如果想让系统支持更多的线程，那麽应该使用一个较小的堆空间。

+ 永久区溢出

永久区存放类的元数据的区域。如果系统定了太多的类型，那麽永久区是有可能溢出的。在JDk1.8中，永久区被一块称为元数据的区域所代替，但他们的功能是类似的，都是为了保存类的元数据信息。

+ GC 效率低下引起OOM

GC是垃圾回收的关键，如果GC效率低下，那麽系统性能会受到严重影响

# 锁与并发

随着多核计算机的兴起，适应于多核计算的多线程开发模式得到越来越多普遍应用。java虚拟机对多线程开发有着很好的支持。其中，一个重要的元素就是对“锁”的实现和优化，主要涉及以下知识点：

+ 理解线程安全的重要性
+ “锁”在虚拟机内的基本实现方式
+ 应用层对“锁“进行优化的一般方法和思路
+ 无锁计算的方法和原理
+ 理解java虚拟机内存模式

1. 锁的基本概念和实现

锁是多线程软件开发的必要工具之一，它的基本作用是保护临界区资源不会被多线程同时访问而破坏。如果多线程访问造成对象数据的不一致，那麽系统运行将会得到错误的结果。通过锁，可以让多个线程排队，一个一个的进入临界区访问目标对象，使目标对象的状态总是保持一致，这也是锁存在的价值。

通过锁可以实现线程安全，对于线程安全简单的理解就是在多线程环境下，无论多个线程访问目标对象，目标对象的状态应该始终保持一致，线程的行为也总是正确。

2. 对象头和锁

在java虚拟机的实现中每个对象都有一个对象头，用于保存对象的系统信息。对象头中有一个称为Mark  World的部分，它是实现锁的关键。在32位系统中，Mark World为一个32位的数据，在64系统中，它占64位。它是一个多功能数据区，可以存放对象的哈希值、对象年龄 、锁的指针等信息。一个对象是否占锁，占有哪个锁，就记录在这个Mark World中。

3, 锁在java虚拟机中的实现和优化

在多线程程序中，线程之间的竞争是不可避免的，而且是一种常态，如何使用更高的效率处理多线程的竞争，是java虚拟机一项重要的使命。如果将所有的线程竞争都交由操作系统，那麽并发的效率会很低。为此，虚拟机在操作系统层面挂起线程之前，会先尽一切可能在虚拟机层面解决竞争关系，仅可能避免真实的竞争发生。同时，在竞争不激烈的场合，也会试图消灭不必要的竞争。采用的这些手段的方法，包括偏向锁、轻量级锁、自旋锁、锁消除、锁膨胀等。

+ 偏向锁

其核心思想是，如果没有竞争，则取消之前已经取得锁的线程同步。也就是说，若某一锁被线程获得，便进入偏向模式，当线程再次请求这个锁时，无需再进行相关操作，从而节省了操作时间。如果在此之间有其他线程进行了锁的请求，则锁退出偏向模式。在JVM中使用-XX：+UseBiasedLocking可以设置偏向锁。

+ 轻量级锁

轻量级锁在java虚拟机内部，使用一个称为BasicObjectock的对象实现，这个对象内部由一个BasicLock对象和一个持有该锁的java对象指针组成。BasicObjectLock对象放置在java栈的栈帧中。在BasicObjectLock对象内部还维护着displaced_header字段，它用于备份对象头部的Mark World。

+ 自旋锁

自旋锁可以使线程在没有取得锁时，不被挂起，而转向去执行一个空循环（即所谓的自旋）。在若干个空循环后，线程如果可以获得锁，则继续执行。若线程仍然不能获得锁，才会被挂起。

## class文件结构

对于java虚拟机来说，class文件是虚拟机的一个重要接口。无论使用任何语言进行编程，只要能将源文件编译为正确的class文件，那麽这和总语言就可以在java虚拟机上执行。可以说，class文件是java虚拟机的基石。

class文件的总体结构如下：

类属性、类方法（访问标记、名称、描述符、属性[行号属性、局部变量表、栈映射帧]）、类字段（访问标记、名称、描述符、属性）、实现接口、父类、当前类、访问标记（public、static）、常量池（各种常量、整数、class）、大版本号、小版本号、魔数（class文件特征）。

calss文件的结构严格按照结构体的定义：

1. 文件以一个4字节的Magic（被成为魔数）开头，紧跟着两个大小版本号。
2. 在版本号之后是常量池，常量池的个数为constant_pool_count，常量池中所有的表项有constant_pool_count-1项。
3. 常量池之后是类的访问修饰符，代表自身类的引用、父类引用以及接口的数量和实现的接口引用。
4. 在接口之后，有着字段的数量和字段描述、方法数量以及方法的描述。
5. 最后，存放着类文件的属性信息。

+ 魔数  作为class文件的标志，用来告诉虚拟机，这是一个class文件。魔数是一个4字节的无符号整数，它固定为0XCAFEBABE
+ class文件的版本  表示当前文件由哪个版本的编译器编译产生。
+ 存放所有常数-----常量池。常量池是calss文件中内容最丰富的区域之一。常量池对于class文件中的字段和方法解析也有着至关重要的作用，可以说常量池是整个class文件的基石。
+ class的访问标记  该标记使用两个字节表示，用于表示该类的访问信息，如public、final、abstract等。

从java虚拟机的角度看，通过class文件，可以让更多的计算机语言支持java虚拟机平台。因此calss文件不仅仅是java虚拟机执行入口，更是java生态圈的基础和核心。

## class装载系统

calss类型通常以文件的形式存在，只有被java虚拟机装载的calss类型文件才能在程序中使用。系统装载class类型可以分为加载、连接和初始化3个步骤。其中连接又可分为验证、准备和解析3步。

classLoader是java核心组件，所有class都是由classLoader进行加载的。classLoder负责通过各种方式将class信息的二进制数据流读入系统，然后交给java虚拟机进行连接、初始化等操作。因此calssloder在整个装载阶段，只能影响到类的加载，而无法通过classLoder取改变类的连接和初始化行为。

在标准的java程序中，java虚拟机会创建3类calssLoder为整个应用程序服务。他们分别是BootStrap  ClassLoder（启动类加载器）、Extension Classloder(扩帧类加载器)和App ClassLoder（应用类加载器）。此外，每一个应用程序还可以拥有自己的自定义的calssLoder，扩展java虚拟机获取class数据的能力。其中应用类加载器的双亲为扩展类加载器，扩展类加载器的双亲为启动类加载器。当系统需要使用一个类时，在判断类是否加载时会先从当前底层类加载器进行判断。当系统需要加载一个类时，会从顶层类开始加载，依次向下尝试，直到成功。

自底向上检查类是否加载（自定义-->应用类-->扩展类-->启动类）

自顶向下尝试加载类（启动类-->扩展类-->应用类-->自定义）

## 字节码执行

字节码执行是java虚拟机的重点，字节码对java虚拟机来说是执行的根本。当java源码被编译成为class文件后，虚拟机就会将calss文件内的方法字节码载入系统加以执行。

## 垃圾回收概念与算法

java虚拟机提供了一套全自动的内存管理方案，尽可能的减少开发人员在内存资源管理方面的工作量。

### 常用垃圾回收算法

常用算法有：引用计数法、标记压缩法、标记清除法、复制算法和分代、分区的思想。

+ 引用计数法

引用计数法很简单，对于对象A，只要由任何一个对象引用了A，则A的引用计数加1,当引用失效时，引用计数减1.只要对象A的引用计数器的值为0,则对象A就不可能被使用。

但引用计数有两个严重的问题：

1. 无法处理循环引用。因此，java垃圾回收算法没有使用这种算法
2. 引用计算器要求每次因引用产生或消除时，需要伴随一个加法和减法操作，对系统性能存在影响。

+ 标记清除法


标记清除法是现代垃圾回收算法的思想基础。标记清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点可达的对象。因此，未被标记的对象就是未被引用的的垃圾对象。然后在清除阶段，清除所有未被标记的对象。标记清除算法可能产生的最大问题是空间碎片。

+ 复制算法

复制算法的核心思想是：将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中所有对象，交换两个内存对象，完成垃圾回收。

在java的新生代串行垃圾回收器中，使用了复制算法思想。新生代分为eden空间、from空间和to空间3个部分。其中from和to空间可以视为复制的两块大小相同、地位相等、且可进行角色交换的空间块。from和to空间也称为survivor空间，即幸存者空间，用于存放被回收对象。

+ 标记压缩算法

标记压缩算法是一种老年代的回收算法。它在标记清除算法的基础上做了一些优化。标记压缩算法也需要从根节点开始，对所有可达对象做一次标记。但之后它不是简单的对未标记对象进行清除，而是将所有存活对象压缩到内存的另一端，之后清理边界外所有空间。这种方法即避免了碎片化的产生，又不需要两块相同的空间。

+ 分代算法

分代算法基于的思想是，它将内存区间根据对象的特点分成几块，根据每块内存区间的特点，使用不同的垃圾回收机制，以提高垃圾回收的效率。如新生代可使用复制算法，老年代可使用标记压缩算法或标记清除算法。

垃圾回收算法的基本思想是考察每个对象的可触及性，即从根节点开始是否访问到这个对象，如果可以，则说明当前对象正在被使用，如果从所有的根节点都无法访问到某个对象，说明对象已经不再使用。一般说，此对象需要被收回。但事实上，一个无法触及的对象有可能在某一条件下复活自己，如果这样回收就不合理。因此，需要给出一个对象可触及状态的定义：

1. 可触及：从根节点开始，可以达到这个对像
2. 可复活：对象的所有引用都被释放，但对象有可能在finalize（）函数中复活。
3. 不可触及：对象的finalize（）函数被调用，并且没有复活，那麽就会进入不可触及状态，不可触及的对象不肯呢个被复活，因为fianlize（）函数只会调用一次。

以上3中状态，只有在对象不可触及时才可以被回收。

## 垃圾收集器和内存分配

在java虚拟机中，垃圾回收器可不仅仅只有一种，什么情况使用哪一种，对性能又有什么样的影响，这都是我们需要了解的。

### 串行回收器

串行回收器是指单线程进行垃圾回收器。每次回收，串行回收器只能一个工作线程，对于并行能力较弱的计算机来说，串行回收器的专注性和独占性往往有更好的性能表现。串行回收器可以在新生代和老年代使用。

### 并行回收器

使用多线程同时进行垃圾回收。对于并行能力强的计算机，可以有效缩短垃圾回收所需的时间。

新生代ParNew回收器

新生代ParallelGC回收器

老年代ParallelGC回收器

### CMS回收器

CMS工作时主要步骤由：初始标记、并发标记、预清理、重新标记、并发清除和并发重置。

### G1回收器

  












